/**
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "TStringBigSetKVService.h"

namespace bskv {


TStringBigSetKVService_bsPutItem_args::~TStringBigSetKVService_bsPutItem_args() noexcept {
}


uint32_t TStringBigSetKVService_bsPutItem_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->item.read(iprot);
          this->__isset.item = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsPutItem_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsPutItem_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->item.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsPutItem_pargs::~TStringBigSetKVService_bsPutItem_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsPutItem_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsPutItem_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("item", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->item)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsPutItem_result::~TStringBigSetKVService_bsPutItem_result() noexcept {
}


uint32_t TStringBigSetKVService_bsPutItem_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsPutItem_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsPutItem_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsPutItem_presult::~TStringBigSetKVService_bsPutItem_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsPutItem_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsRemoveItem_args::~TStringBigSetKVService_bsRemoveItem_args() noexcept {
}


uint32_t TStringBigSetKVService_bsRemoveItem_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->itemKey);
          this->__isset.itemKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsRemoveItem_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRemoveItem_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->itemKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRemoveItem_pargs::~TStringBigSetKVService_bsRemoveItem_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsRemoveItem_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRemoveItem_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->itemKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRemoveItem_result::~TStringBigSetKVService_bsRemoveItem_result() noexcept {
}


uint32_t TStringBigSetKVService_bsRemoveItem_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsRemoveItem_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRemoveItem_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 0);
    xfer += oprot->writeBool(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRemoveItem_presult::~TStringBigSetKVService_bsRemoveItem_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsRemoveItem_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsExisted_args::~TStringBigSetKVService_bsExisted_args() noexcept {
}


uint32_t TStringBigSetKVService_bsExisted_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->itemKey);
          this->__isset.itemKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsExisted_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsExisted_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->itemKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsExisted_pargs::~TStringBigSetKVService_bsExisted_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsExisted_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsExisted_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->itemKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsExisted_result::~TStringBigSetKVService_bsExisted_result() noexcept {
}


uint32_t TStringBigSetKVService_bsExisted_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsExisted_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsExisted_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsExisted_presult::~TStringBigSetKVService_bsExisted_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsExisted_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsGetItem_args::~TStringBigSetKVService_bsGetItem_args() noexcept {
}


uint32_t TStringBigSetKVService_bsGetItem_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->itemKey);
          this->__isset.itemKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetItem_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetItem_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->itemKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetItem_pargs::~TStringBigSetKVService_bsGetItem_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsGetItem_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetItem_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->itemKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetItem_result::~TStringBigSetKVService_bsGetItem_result() noexcept {
}


uint32_t TStringBigSetKVService_bsGetItem_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetItem_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetItem_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetItem_presult::~TStringBigSetKVService_bsGetItem_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsGetItem_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsGetSlice_args::~TStringBigSetKVService_bsGetSlice_args() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSlice_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fromPos);
          this->__isset.fromPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSlice_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSlice_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fromPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSlice_pargs::~TStringBigSetKVService_bsGetSlice_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSlice_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSlice_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->fromPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSlice_result::~TStringBigSetKVService_bsGetSlice_result() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSlice_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSlice_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSlice_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSlice_presult::~TStringBigSetKVService_bsGetSlice_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSlice_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItem_args::~TStringBigSetKVService_bsGetSliceFromItem_args() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItem_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fromKey);
          this->__isset.fromKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceFromItem_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItem_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->fromKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItem_pargs::~TStringBigSetKVService_bsGetSliceFromItem_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItem_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItem_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->fromKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItem_result::~TStringBigSetKVService_bsGetSliceFromItem_result() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItem_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceFromItem_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItem_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItem_presult::~TStringBigSetKVService_bsGetSliceFromItem_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItem_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsGetSliceR_args::~TStringBigSetKVService_bsGetSliceR_args() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceR_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fromPos);
          this->__isset.fromPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceR_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceR_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->fromPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceR_pargs::~TStringBigSetKVService_bsGetSliceR_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceR_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceR_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->fromPos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceR_result::~TStringBigSetKVService_bsGetSliceR_result() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceR_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceR_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceR_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceR_presult::~TStringBigSetKVService_bsGetSliceR_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceR_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItemR_args::~TStringBigSetKVService_bsGetSliceFromItemR_args() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItemR_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->fromKey);
          this->__isset.fromKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceFromItemR_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItemR_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->fromKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItemR_pargs::~TStringBigSetKVService_bsGetSliceFromItemR_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItemR_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItemR_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fromKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->fromKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->count)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItemR_result::~TStringBigSetKVService_bsGetSliceFromItemR_result() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItemR_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsGetSliceFromItemR_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsGetSliceFromItemR_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsGetSliceFromItemR_presult::~TStringBigSetKVService_bsGetSliceFromItemR_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsGetSliceFromItemR_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsRangeQuery_args::~TStringBigSetKVService_bsRangeQuery_args() noexcept {
}


uint32_t TStringBigSetKVService_bsRangeQuery_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->startKey);
          this->__isset.startKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->endKey);
          this->__isset.endKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsRangeQuery_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRangeQuery_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->startKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->endKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRangeQuery_pargs::~TStringBigSetKVService_bsRangeQuery_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsRangeQuery_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRangeQuery_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("startKey", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary((*(this->startKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endKey", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary((*(this->endKey)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRangeQuery_result::~TStringBigSetKVService_bsRangeQuery_result() noexcept {
}


uint32_t TStringBigSetKVService_bsRangeQuery_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsRangeQuery_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsRangeQuery_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsRangeQuery_presult::~TStringBigSetKVService_bsRangeQuery_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsRangeQuery_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_bsMultiPut_args::~TStringBigSetKVService_bsMultiPut_args() noexcept {
}


uint32_t TStringBigSetKVService_bsMultiPut_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->setData.read(iprot);
          this->__isset.setData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getAddedItems);
          this->__isset.getAddedItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->getReplacedItems);
          this->__isset.getReplacedItems = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsMultiPut_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsMultiPut_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->setData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getAddedItems", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->getAddedItems);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getReplacedItems", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->getReplacedItems);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsMultiPut_pargs::~TStringBigSetKVService_bsMultiPut_pargs() noexcept {
}


uint32_t TStringBigSetKVService_bsMultiPut_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsMultiPut_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("setData", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->setData)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getAddedItems", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool((*(this->getAddedItems)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("getReplacedItems", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool((*(this->getReplacedItems)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsMultiPut_result::~TStringBigSetKVService_bsMultiPut_result() noexcept {
}


uint32_t TStringBigSetKVService_bsMultiPut_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_bsMultiPut_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_bsMultiPut_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_bsMultiPut_presult::~TStringBigSetKVService_bsMultiPut_presult() noexcept {
}


uint32_t TStringBigSetKVService_bsMultiPut_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_getTotalCount_args::~TStringBigSetKVService_getTotalCount_args() noexcept {
}


uint32_t TStringBigSetKVService_getTotalCount_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_getTotalCount_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_getTotalCount_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_getTotalCount_pargs::~TStringBigSetKVService_getTotalCount_pargs() noexcept {
}


uint32_t TStringBigSetKVService_getTotalCount_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_getTotalCount_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_getTotalCount_result::~TStringBigSetKVService_getTotalCount_result() noexcept {
}


uint32_t TStringBigSetKVService_getTotalCount_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_getTotalCount_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_getTotalCount_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_getTotalCount_presult::~TStringBigSetKVService_getTotalCount_presult() noexcept {
}


uint32_t TStringBigSetKVService_getTotalCount_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


TStringBigSetKVService_removeAll_args::~TStringBigSetKVService_removeAll_args() noexcept {
}


uint32_t TStringBigSetKVService_removeAll_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->bsName);
          this->__isset.bsName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_removeAll_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_removeAll_args");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->bsName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_removeAll_pargs::~TStringBigSetKVService_removeAll_pargs() noexcept {
}


uint32_t TStringBigSetKVService_removeAll_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TStringBigSetKVService_removeAll_pargs");

  xfer += oprot->writeFieldBegin("bsName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->bsName)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_removeAll_result::~TStringBigSetKVService_removeAll_result() noexcept {
}


uint32_t TStringBigSetKVService_removeAll_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TStringBigSetKVService_removeAll_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("TStringBigSetKVService_removeAll_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I64, 0);
    xfer += oprot->writeI64(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


TStringBigSetKVService_removeAll_presult::~TStringBigSetKVService_removeAll_presult() noexcept {
}


uint32_t TStringBigSetKVService_removeAll_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void TStringBigSetKVServiceClient::bsPutItem(TPutItemResult& _return, const TStringKey& bsName, const TItem& item)
{
  send_bsPutItem(bsName, item);
  recv_bsPutItem(_return);
}

void TStringBigSetKVServiceClient::send_bsPutItem(const TStringKey& bsName, const TItem& item)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsPutItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsPutItem_pargs args;
  args.bsName = &bsName;
  args.item = &item;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsPutItem(TPutItemResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsPutItem") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsPutItem_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsPutItem failed: unknown result");
}

bool TStringBigSetKVServiceClient::bsRemoveItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  send_bsRemoveItem(bsName, itemKey);
  return recv_bsRemoveItem();
}

void TStringBigSetKVServiceClient::send_bsRemoveItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsRemoveItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsRemoveItem_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool TStringBigSetKVServiceClient::recv_bsRemoveItem()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsRemoveItem") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  bool _return;
  TStringBigSetKVService_bsRemoveItem_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsRemoveItem failed: unknown result");
}

void TStringBigSetKVServiceClient::bsExisted(TExistedResult& _return, const TStringKey& bsName, const TItemKey& itemKey)
{
  send_bsExisted(bsName, itemKey);
  recv_bsExisted(_return);
}

void TStringBigSetKVServiceClient::send_bsExisted(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsExisted", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsExisted_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsExisted(TExistedResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsExisted") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsExisted_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsExisted failed: unknown result");
}

void TStringBigSetKVServiceClient::bsGetItem(TItemResult& _return, const TStringKey& bsName, const TItemKey& itemKey)
{
  send_bsGetItem(bsName, itemKey);
  recv_bsGetItem(_return);
}

void TStringBigSetKVServiceClient::send_bsGetItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsGetItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetItem_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsGetItem(TItemResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsGetItem") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsGetItem_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetItem failed: unknown result");
}

void TStringBigSetKVServiceClient::bsGetSlice(TItemSetResult& _return, const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  send_bsGetSlice(bsName, fromPos, count);
  recv_bsGetSlice(_return);
}

void TStringBigSetKVServiceClient::send_bsGetSlice(const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsGetSlice", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSlice_pargs args;
  args.bsName = &bsName;
  args.fromPos = &fromPos;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsGetSlice(TItemSetResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsGetSlice") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsGetSlice_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSlice failed: unknown result");
}

void TStringBigSetKVServiceClient::bsGetSliceFromItem(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  send_bsGetSliceFromItem(bsName, fromKey, count);
  recv_bsGetSliceFromItem(_return);
}

void TStringBigSetKVServiceClient::send_bsGetSliceFromItem(const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsGetSliceFromItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceFromItem_pargs args;
  args.bsName = &bsName;
  args.fromKey = &fromKey;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsGetSliceFromItem(TItemSetResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsGetSliceFromItem") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsGetSliceFromItem_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceFromItem failed: unknown result");
}

void TStringBigSetKVServiceClient::bsGetSliceR(TItemSetResult& _return, const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  send_bsGetSliceR(bsName, fromPos, count);
  recv_bsGetSliceR(_return);
}

void TStringBigSetKVServiceClient::send_bsGetSliceR(const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsGetSliceR", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceR_pargs args;
  args.bsName = &bsName;
  args.fromPos = &fromPos;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsGetSliceR(TItemSetResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsGetSliceR") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsGetSliceR_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceR failed: unknown result");
}

void TStringBigSetKVServiceClient::bsGetSliceFromItemR(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  send_bsGetSliceFromItemR(bsName, fromKey, count);
  recv_bsGetSliceFromItemR(_return);
}

void TStringBigSetKVServiceClient::send_bsGetSliceFromItemR(const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsGetSliceFromItemR", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceFromItemR_pargs args;
  args.bsName = &bsName;
  args.fromKey = &fromKey;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsGetSliceFromItemR(TItemSetResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsGetSliceFromItemR") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsGetSliceFromItemR_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceFromItemR failed: unknown result");
}

void TStringBigSetKVServiceClient::bsRangeQuery(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& startKey, const TItemKey& endKey)
{
  send_bsRangeQuery(bsName, startKey, endKey);
  recv_bsRangeQuery(_return);
}

void TStringBigSetKVServiceClient::send_bsRangeQuery(const TStringKey& bsName, const TItemKey& startKey, const TItemKey& endKey)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsRangeQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsRangeQuery_pargs args;
  args.bsName = &bsName;
  args.startKey = &startKey;
  args.endKey = &endKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsRangeQuery(TItemSetResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsRangeQuery") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsRangeQuery_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsRangeQuery failed: unknown result");
}

void TStringBigSetKVServiceClient::bsMultiPut(TMultiPutItemResult& _return, const TStringKey& bsName, const TItemSet& setData, const bool getAddedItems, const bool getReplacedItems)
{
  send_bsMultiPut(bsName, setData, getAddedItems, getReplacedItems);
  recv_bsMultiPut(_return);
}

void TStringBigSetKVServiceClient::send_bsMultiPut(const TStringKey& bsName, const TItemSet& setData, const bool getAddedItems, const bool getReplacedItems)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("bsMultiPut", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsMultiPut_pargs args;
  args.bsName = &bsName;
  args.setData = &setData;
  args.getAddedItems = &getAddedItems;
  args.getReplacedItems = &getReplacedItems;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void TStringBigSetKVServiceClient::recv_bsMultiPut(TMultiPutItemResult& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("bsMultiPut") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  TStringBigSetKVService_bsMultiPut_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsMultiPut failed: unknown result");
}

int64_t TStringBigSetKVServiceClient::getTotalCount(const TStringKey& bsName)
{
  send_getTotalCount(bsName);
  return recv_getTotalCount();
}

void TStringBigSetKVServiceClient::send_getTotalCount(const TStringKey& bsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("getTotalCount", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_getTotalCount_pargs args;
  args.bsName = &bsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t TStringBigSetKVServiceClient::recv_getTotalCount()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("getTotalCount") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  TStringBigSetKVService_getTotalCount_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTotalCount failed: unknown result");
}

int64_t TStringBigSetKVServiceClient::removeAll(const TStringKey& bsName)
{
  send_removeAll(bsName);
  return recv_removeAll();
}

void TStringBigSetKVServiceClient::send_removeAll(const TStringKey& bsName)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("removeAll", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_removeAll_pargs args;
  args.bsName = &bsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int64_t TStringBigSetKVServiceClient::recv_removeAll()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("removeAll") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int64_t _return;
  TStringBigSetKVService_removeAll_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeAll failed: unknown result");
}

bool TStringBigSetKVServiceProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void TStringBigSetKVServiceProcessor::process_bsPutItem(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsPutItem", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsPutItem");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsPutItem");
  }

  TStringBigSetKVService_bsPutItem_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsPutItem", bytes);
  }

  TStringBigSetKVService_bsPutItem_result result;
  try {
    iface_->bsPutItem(result.success, args.bsName, args.item);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsPutItem");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsPutItem", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsPutItem");
  }

  oprot->writeMessageBegin("bsPutItem", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsPutItem", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsRemoveItem(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsRemoveItem", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsRemoveItem");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsRemoveItem");
  }

  TStringBigSetKVService_bsRemoveItem_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsRemoveItem", bytes);
  }

  TStringBigSetKVService_bsRemoveItem_result result;
  try {
    result.success = iface_->bsRemoveItem(args.bsName, args.itemKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsRemoveItem");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsRemoveItem", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsRemoveItem");
  }

  oprot->writeMessageBegin("bsRemoveItem", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsRemoveItem", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsExisted(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsExisted", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsExisted");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsExisted");
  }

  TStringBigSetKVService_bsExisted_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsExisted", bytes);
  }

  TStringBigSetKVService_bsExisted_result result;
  try {
    iface_->bsExisted(result.success, args.bsName, args.itemKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsExisted");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsExisted", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsExisted");
  }

  oprot->writeMessageBegin("bsExisted", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsExisted", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsGetItem(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsGetItem", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsGetItem");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsGetItem");
  }

  TStringBigSetKVService_bsGetItem_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsGetItem", bytes);
  }

  TStringBigSetKVService_bsGetItem_result result;
  try {
    iface_->bsGetItem(result.success, args.bsName, args.itemKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsGetItem");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsGetItem", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsGetItem");
  }

  oprot->writeMessageBegin("bsGetItem", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsGetItem", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsGetSlice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsGetSlice", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsGetSlice");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsGetSlice");
  }

  TStringBigSetKVService_bsGetSlice_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsGetSlice", bytes);
  }

  TStringBigSetKVService_bsGetSlice_result result;
  try {
    iface_->bsGetSlice(result.success, args.bsName, args.fromPos, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsGetSlice");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsGetSlice", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsGetSlice");
  }

  oprot->writeMessageBegin("bsGetSlice", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsGetSlice", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsGetSliceFromItem(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsGetSliceFromItem", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsGetSliceFromItem");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsGetSliceFromItem");
  }

  TStringBigSetKVService_bsGetSliceFromItem_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsGetSliceFromItem", bytes);
  }

  TStringBigSetKVService_bsGetSliceFromItem_result result;
  try {
    iface_->bsGetSliceFromItem(result.success, args.bsName, args.fromKey, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsGetSliceFromItem");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsGetSliceFromItem", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsGetSliceFromItem");
  }

  oprot->writeMessageBegin("bsGetSliceFromItem", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsGetSliceFromItem", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsGetSliceR(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsGetSliceR", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsGetSliceR");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsGetSliceR");
  }

  TStringBigSetKVService_bsGetSliceR_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsGetSliceR", bytes);
  }

  TStringBigSetKVService_bsGetSliceR_result result;
  try {
    iface_->bsGetSliceR(result.success, args.bsName, args.fromPos, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsGetSliceR");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsGetSliceR", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsGetSliceR");
  }

  oprot->writeMessageBegin("bsGetSliceR", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsGetSliceR", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsGetSliceFromItemR(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsGetSliceFromItemR", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsGetSliceFromItemR");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsGetSliceFromItemR");
  }

  TStringBigSetKVService_bsGetSliceFromItemR_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsGetSliceFromItemR", bytes);
  }

  TStringBigSetKVService_bsGetSliceFromItemR_result result;
  try {
    iface_->bsGetSliceFromItemR(result.success, args.bsName, args.fromKey, args.count);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsGetSliceFromItemR");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsGetSliceFromItemR", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsGetSliceFromItemR");
  }

  oprot->writeMessageBegin("bsGetSliceFromItemR", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsGetSliceFromItemR", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsRangeQuery(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsRangeQuery", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsRangeQuery");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsRangeQuery");
  }

  TStringBigSetKVService_bsRangeQuery_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsRangeQuery", bytes);
  }

  TStringBigSetKVService_bsRangeQuery_result result;
  try {
    iface_->bsRangeQuery(result.success, args.bsName, args.startKey, args.endKey);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsRangeQuery");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsRangeQuery", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsRangeQuery");
  }

  oprot->writeMessageBegin("bsRangeQuery", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsRangeQuery", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_bsMultiPut(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.bsMultiPut", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.bsMultiPut");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.bsMultiPut");
  }

  TStringBigSetKVService_bsMultiPut_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.bsMultiPut", bytes);
  }

  TStringBigSetKVService_bsMultiPut_result result;
  try {
    iface_->bsMultiPut(result.success, args.bsName, args.setData, args.getAddedItems, args.getReplacedItems);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.bsMultiPut");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("bsMultiPut", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.bsMultiPut");
  }

  oprot->writeMessageBegin("bsMultiPut", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.bsMultiPut", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_getTotalCount(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.getTotalCount", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.getTotalCount");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.getTotalCount");
  }

  TStringBigSetKVService_getTotalCount_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.getTotalCount", bytes);
  }

  TStringBigSetKVService_getTotalCount_result result;
  try {
    result.success = iface_->getTotalCount(args.bsName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.getTotalCount");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("getTotalCount", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.getTotalCount");
  }

  oprot->writeMessageBegin("getTotalCount", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.getTotalCount", bytes);
  }
}

void TStringBigSetKVServiceProcessor::process_removeAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = nullptr;
  if (this->eventHandler_.get() != nullptr) {
    ctx = this->eventHandler_->getContext("TStringBigSetKVService.removeAll", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "TStringBigSetKVService.removeAll");

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preRead(ctx, "TStringBigSetKVService.removeAll");
  }

  TStringBigSetKVService_removeAll_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postRead(ctx, "TStringBigSetKVService.removeAll", bytes);
  }

  TStringBigSetKVService_removeAll_result result;
  try {
    result.success = iface_->removeAll(args.bsName);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != nullptr) {
      this->eventHandler_->handlerError(ctx, "TStringBigSetKVService.removeAll");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("removeAll", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->preWrite(ctx, "TStringBigSetKVService.removeAll");
  }

  oprot->writeMessageBegin("removeAll", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != nullptr) {
    this->eventHandler_->postWrite(ctx, "TStringBigSetKVService.removeAll", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > TStringBigSetKVServiceProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< TStringBigSetKVServiceIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< TStringBigSetKVServiceIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new TStringBigSetKVServiceProcessor(handler));
  return processor;
}

void TStringBigSetKVServiceConcurrentClient::bsPutItem(TPutItemResult& _return, const TStringKey& bsName, const TItem& item)
{
  int32_t seqid = send_bsPutItem(bsName, item);
  recv_bsPutItem(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsPutItem(const TStringKey& bsName, const TItem& item)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsPutItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsPutItem_pargs args;
  args.bsName = &bsName;
  args.item = &item;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsPutItem(TPutItemResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsPutItem") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsPutItem_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsPutItem failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

bool TStringBigSetKVServiceConcurrentClient::bsRemoveItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t seqid = send_bsRemoveItem(bsName, itemKey);
  return recv_bsRemoveItem(seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsRemoveItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsRemoveItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsRemoveItem_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

bool TStringBigSetKVServiceConcurrentClient::recv_bsRemoveItem(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsRemoveItem") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      bool _return;
      TStringBigSetKVService_bsRemoveItem_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsRemoveItem failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsExisted(TExistedResult& _return, const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t seqid = send_bsExisted(bsName, itemKey);
  recv_bsExisted(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsExisted(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsExisted", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsExisted_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsExisted(TExistedResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsExisted") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsExisted_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsExisted failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsGetItem(TItemResult& _return, const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t seqid = send_bsGetItem(bsName, itemKey);
  recv_bsGetItem(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsGetItem(const TStringKey& bsName, const TItemKey& itemKey)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsGetItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetItem_pargs args;
  args.bsName = &bsName;
  args.itemKey = &itemKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsGetItem(TItemResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsGetItem") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsGetItem_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetItem failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsGetSlice(TItemSetResult& _return, const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t seqid = send_bsGetSlice(bsName, fromPos, count);
  recv_bsGetSlice(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsGetSlice(const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsGetSlice", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSlice_pargs args;
  args.bsName = &bsName;
  args.fromPos = &fromPos;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsGetSlice(TItemSetResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsGetSlice") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsGetSlice_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSlice failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsGetSliceFromItem(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t seqid = send_bsGetSliceFromItem(bsName, fromKey, count);
  recv_bsGetSliceFromItem(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsGetSliceFromItem(const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsGetSliceFromItem", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceFromItem_pargs args;
  args.bsName = &bsName;
  args.fromKey = &fromKey;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsGetSliceFromItem(TItemSetResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsGetSliceFromItem") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsGetSliceFromItem_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceFromItem failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsGetSliceR(TItemSetResult& _return, const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t seqid = send_bsGetSliceR(bsName, fromPos, count);
  recv_bsGetSliceR(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsGetSliceR(const TStringKey& bsName, const int32_t fromPos, const int32_t count)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsGetSliceR", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceR_pargs args;
  args.bsName = &bsName;
  args.fromPos = &fromPos;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsGetSliceR(TItemSetResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsGetSliceR") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsGetSliceR_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceR failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsGetSliceFromItemR(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t seqid = send_bsGetSliceFromItemR(bsName, fromKey, count);
  recv_bsGetSliceFromItemR(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsGetSliceFromItemR(const TStringKey& bsName, const TItemKey& fromKey, const int32_t count)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsGetSliceFromItemR", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsGetSliceFromItemR_pargs args;
  args.bsName = &bsName;
  args.fromKey = &fromKey;
  args.count = &count;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsGetSliceFromItemR(TItemSetResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsGetSliceFromItemR") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsGetSliceFromItemR_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsGetSliceFromItemR failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsRangeQuery(TItemSetResult& _return, const TStringKey& bsName, const TItemKey& startKey, const TItemKey& endKey)
{
  int32_t seqid = send_bsRangeQuery(bsName, startKey, endKey);
  recv_bsRangeQuery(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsRangeQuery(const TStringKey& bsName, const TItemKey& startKey, const TItemKey& endKey)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsRangeQuery", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsRangeQuery_pargs args;
  args.bsName = &bsName;
  args.startKey = &startKey;
  args.endKey = &endKey;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsRangeQuery(TItemSetResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsRangeQuery") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsRangeQuery_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsRangeQuery failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void TStringBigSetKVServiceConcurrentClient::bsMultiPut(TMultiPutItemResult& _return, const TStringKey& bsName, const TItemSet& setData, const bool getAddedItems, const bool getReplacedItems)
{
  int32_t seqid = send_bsMultiPut(bsName, setData, getAddedItems, getReplacedItems);
  recv_bsMultiPut(_return, seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_bsMultiPut(const TStringKey& bsName, const TItemSet& setData, const bool getAddedItems, const bool getReplacedItems)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("bsMultiPut", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_bsMultiPut_pargs args;
  args.bsName = &bsName;
  args.setData = &setData;
  args.getAddedItems = &getAddedItems;
  args.getReplacedItems = &getReplacedItems;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void TStringBigSetKVServiceConcurrentClient::recv_bsMultiPut(TMultiPutItemResult& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("bsMultiPut") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      TStringBigSetKVService_bsMultiPut_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "bsMultiPut failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int64_t TStringBigSetKVServiceConcurrentClient::getTotalCount(const TStringKey& bsName)
{
  int32_t seqid = send_getTotalCount(bsName);
  return recv_getTotalCount(seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_getTotalCount(const TStringKey& bsName)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("getTotalCount", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_getTotalCount_pargs args;
  args.bsName = &bsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t TStringBigSetKVServiceConcurrentClient::recv_getTotalCount(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("getTotalCount") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      TStringBigSetKVService_getTotalCount_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "getTotalCount failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

int64_t TStringBigSetKVServiceConcurrentClient::removeAll(const TStringKey& bsName)
{
  int32_t seqid = send_removeAll(bsName);
  return recv_removeAll(seqid);
}

int32_t TStringBigSetKVServiceConcurrentClient::send_removeAll(const TStringKey& bsName)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("removeAll", ::apache::thrift::protocol::T_CALL, cseqid);

  TStringBigSetKVService_removeAll_pargs args;
  args.bsName = &bsName;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int64_t TStringBigSetKVServiceConcurrentClient::recv_removeAll(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("removeAll") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int64_t _return;
      TStringBigSetKVService_removeAll_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "removeAll failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

